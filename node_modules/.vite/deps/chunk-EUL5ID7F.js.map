{
  "version": 3,
  "sources": ["../../use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../use-sync-external-store/shim/index.js"],
  "sourcesContent": ["/**\r\n * @license React\r\n * use-sync-external-store-shim.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n\r\n          'use strict';\r\n\r\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\r\nif (\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\r\n    'function'\r\n) {\r\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\r\n}\r\n          var React = require('react');\r\n\r\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\n\r\nfunction error(format) {\r\n  {\r\n    {\r\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n        args[_key2 - 1] = arguments[_key2];\r\n      }\r\n\r\n      printWarning('error', format, args);\r\n    }\r\n  }\r\n}\r\n\r\nfunction printWarning(level, format, args) {\r\n  // When changing this logic, you might want to also\r\n  // update consoleWithStackDev.www.js as well.\r\n  {\r\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\r\n\r\n    if (stack !== '') {\r\n      format += '%s';\r\n      args = args.concat([stack]);\r\n    } // eslint-disable-next-line react-internal/safe-string-coercion\r\n\r\n\r\n    var argsWithFormat = args.map(function (item) {\r\n      return String(item);\r\n    }); // Careful: RN currently depends on this prefix\r\n\r\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\r\n    // breaks IE9: https://github.com/facebook/react/issues/13610\r\n    // eslint-disable-next-line react-internal/no-production-logging\r\n\r\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\r\n  }\r\n}\r\n\r\n/**\r\n * inlined Object.is polyfill to avoid requiring consumers ship their own\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n */\r\nfunction is(x, y) {\r\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\r\n  ;\r\n}\r\n\r\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\r\n\r\n// dispatch for CommonJS interop named imports.\r\n\r\nvar useState = React.useState,\r\n    useEffect = React.useEffect,\r\n    useLayoutEffect = React.useLayoutEffect,\r\n    useDebugValue = React.useDebugValue;\r\nvar didWarnOld18Alpha = false;\r\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\r\n// because of a very particular set of implementation details and assumptions\r\n// -- change any one of them and it will break. The most important assumption\r\n// is that updates are always synchronous, because concurrent rendering is\r\n// only available in versions of React that also have a built-in\r\n// useSyncExternalStore API. And we only use this shim when the built-in API\r\n// does not exist.\r\n//\r\n// Do not assume that the clever hacks used by this hook also work in general.\r\n// The point of this shim is to replace the need for hacks by other libraries.\r\n\r\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\r\n// React do not expose a way to check if we're hydrating. So users of the shim\r\n// will need to track that themselves and return the correct value\r\n// from `getSnapshot`.\r\ngetServerSnapshot) {\r\n  {\r\n    if (!didWarnOld18Alpha) {\r\n      if (React.startTransition !== undefined) {\r\n        didWarnOld18Alpha = true;\r\n\r\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\r\n      }\r\n    }\r\n  } // Read the current snapshot from the store on every render. Again, this\r\n  // breaks the rules of React, and only works here because of specific\r\n  // implementation details, most importantly that updates are\r\n  // always synchronous.\r\n\r\n\r\n  var value = getSnapshot();\r\n\r\n  {\r\n    if (!didWarnUncachedGetSnapshot) {\r\n      var cachedValue = getSnapshot();\r\n\r\n      if (!objectIs(value, cachedValue)) {\r\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\r\n\r\n        didWarnUncachedGetSnapshot = true;\r\n      }\r\n    }\r\n  } // Because updates are synchronous, we don't queue them. Instead we force a\r\n  // re-render whenever the subscribed state changes by updating an some\r\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\r\n  // the current value.\r\n  //\r\n  // Because we don't actually use the state returned by the useState hook, we\r\n  // can save a bit of memory by storing other stuff in that slot.\r\n  //\r\n  // To implement the early bailout, we need to track some things on a mutable\r\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\r\n  // our useState hook instead.\r\n  //\r\n  // To force a re-render, we call forceUpdate({inst}). That works because the\r\n  // new object always fails an equality check.\r\n\r\n\r\n  var _useState = useState({\r\n    inst: {\r\n      value: value,\r\n      getSnapshot: getSnapshot\r\n    }\r\n  }),\r\n      inst = _useState[0].inst,\r\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\r\n  // in the layout phase so we can access it during the tearing check that\r\n  // happens on subscribe.\r\n\r\n\r\n  useLayoutEffect(function () {\r\n    inst.value = value;\r\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\r\n    // commit phase if there was an interleaved mutation. In concurrent mode\r\n    // this can happen all the time, but even in synchronous mode, an earlier\r\n    // effect may have mutated the store.\r\n\r\n    if (checkIfSnapshotChanged(inst)) {\r\n      // Force a re-render.\r\n      forceUpdate({\r\n        inst: inst\r\n      });\r\n    }\r\n  }, [subscribe, value, getSnapshot]);\r\n  useEffect(function () {\r\n    // Check for changes right before subscribing. Subsequent changes will be\r\n    // detected in the subscription handler.\r\n    if (checkIfSnapshotChanged(inst)) {\r\n      // Force a re-render.\r\n      forceUpdate({\r\n        inst: inst\r\n      });\r\n    }\r\n\r\n    var handleStoreChange = function () {\r\n      // TODO: Because there is no cross-renderer API for batching updates, it's\r\n      // up to the consumer of this library to wrap their subscription event\r\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\r\n      // the case and print a warning in development?\r\n      // The store changed. Check if the snapshot changed since the last time we\r\n      // read from the store.\r\n      if (checkIfSnapshotChanged(inst)) {\r\n        // Force a re-render.\r\n        forceUpdate({\r\n          inst: inst\r\n        });\r\n      }\r\n    }; // Subscribe to the store and return a clean-up function.\r\n\r\n\r\n    return subscribe(handleStoreChange);\r\n  }, [subscribe]);\r\n  useDebugValue(value);\r\n  return value;\r\n}\r\n\r\nfunction checkIfSnapshotChanged(inst) {\r\n  var latestGetSnapshot = inst.getSnapshot;\r\n  var prevValue = inst.value;\r\n\r\n  try {\r\n    var nextValue = latestGetSnapshot();\r\n    return !objectIs(prevValue, nextValue);\r\n  } catch (error) {\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\r\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\r\n  // React do not expose a way to check if we're hydrating. So users of the shim\r\n  // will need to track that themselves and return the correct value\r\n  // from `getSnapshot`.\r\n  return getSnapshot();\r\n}\r\n\r\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\r\n\r\nvar isServerEnvironment = !canUseDOM;\r\n\r\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\r\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\r\n\r\nexports.useSyncExternalStore = useSyncExternalStore$2;\r\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\r\nif (\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\r\n    'function'\r\n) {\r\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\r\n}\r\n        \r\n  })();\r\n}\r\n", "'use strict';\r\n\r\nif (process.env.NODE_ENV === 'production') {\r\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\r\n} else {\r\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\r\n}\r\n"],
  "mappings": "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",
  "names": ["error"]
}
